// utf8.h

#pragma once

#include <inttypes.h>
#include <string.h>

typedef uint32_t ucp; // Unicode Code Point
typedef uint8_t byte;

enum {
	// Error codes
	UTF8_ERROR_INVALID_START_BYTE = 1,
	UTF8_ERROR_INVALID_CONTINUATION_BYTE,
	UTF8_ERROR_OVERLONG_SEQUENCE,
	UTF8_ERROR_CHARACTER_OVERFLOW,
	UTF8_ERROR_BYTE_OVERFLOW,
	UTF8_ERROR_UNEXPECTED_TERMINATION,
	UTF8_ERROR_INVALID_CHARACTER,
	// Constants
	UTF8_MAX_POINT = 0x1fffff,
};

//
// UTF-8 Decoder
//
// This struct and associated functions can be used for on-line decoding of byte streams.
// It is the basis for the array-based decoding functions.
struct utf8_decoder {
	byte state;
	ucp c;
};

// Prepares a decoder for use
void utf8_decoder_init(struct utf8_decoder*);

// Decodes the given byte.
// If an invalid byte is given, *error will be set to the appropriate error code.
// Otherwise, *error will be set to 0.
// If a character is generated by decoding the given byte, *c will be set to that character and the return value will point to the character after *c.
ucp *utf8_decoder_decode(struct utf8_decoder*, byte b, ucp *c, int *error);

// Returns non-zero if the decoder is in a state where the input can be terminated (i.e., returns whether the decoder is NOT in the middle of a multi-byte sequence).
int utf8_decoder_can_terminate(struct utf8_decoder*);

//
// UTF-8 Decoding Functions
//
// Decodes bc bytes in the ba byte array generating up to cc characters in the ca character array.
// If an error occurs, *error will be set to the appropriate error code.
// If no error occurs, *error will be set to 0.
// Returns a pointer to the next (unused) character.
ucp *utf8_decode_array(const byte *ba, size_t bc, ucp *ca, size_t cc, int *error);

// Similar to the above, except that the input byte array is a char array terminated by null.
ucp *utf8_decode_string(const char *str, ucp *ca, size_t cc, int *error);

//
// UTF-8 Encoding Functions
//
// Returns the number of bytes necessary to encode the given character.
// If an error occurs, *error will be set to the appropriate error code and the return value will be zero.
// If no error occurs, *error will be set to 0 and the return value will be between 1 and 4 inclusively.
// The only error which may occur is UTF8_ERROR_INVALID_CHARACTER.
size_t utf8_bytes_for_char(ucp c, int *error);

// Returns the number of bytes necessary to encode all the characters in the given array.
// If an error occurs, *error will be set to the appropriate error code and the return value will be zero.
// If no error occurs, *error will be set to 0.
// The only error which may occur is UTF8_ERROR_INVALID_CHARACTER.
size_t utf8_bytes_for_array(const ucp *ca, size_t cc, int *error);

// Encodes the given character into the given array of bytes of the given length.
// If an error occurs, *error will be set to the appropriate error code.
// If no error occurs, *error will be set to 0.
// Returns a pointer to the next (unused) byte.
byte *utf8_encode_char(ucp, byte *array, size_t len, int *error);

// Encodes cc characters from the ca character array into up to bc bytes of the ba byte array.
// If an error occurs, *error will be set to the appropriate error code.
// If no error occurs, *error will be set to 0.
// Returns a pointer to the next (unused) byte.
byte *utf8_encode_array(const ucp *ca, size_t cc, byte *ba, size_t bc, int *error);
